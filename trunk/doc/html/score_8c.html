<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SimAnn: fly/score.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>fly/score.c File Reference</h1>
<p>Function implementation for reading and defining facts/limits, and for scoring.  
<a href="#_details">More...</a></p>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="score_8h_source.html">score.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="integrate_8h_source.html">integrate.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fly__io_8h_source.html">fly_io.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="solvers_8h_source.html">solvers.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ioTools_8h_source.html">ioTools.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structScoring.html">Scoring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#aa8cf2f048908ec245bd5832dfb76e5ae">InitScoring</a> (FILE *fp, int method, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTweak.html">Tweak</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a5062990a4365a5c5e5f4926691177e3c">InitTweak</a> (FILE *fp, int *mask, <a class="el" href="structTheProblem.html">TheProblem</a> defs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFacts.html">Facts</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a5a0111317ff208d650540857c1cc1675">InitFacts</a> (FILE *fp, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataTable.html">DataTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a99d47fb9d05f4c80bee60a346c47ffdc">getFact</a> (int i, <a class="el" href="structGenoType.html">GenoType</a> *facttype)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structWeights.html">Weights</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a76abc0d14c58dd765039064041f0b62c">InitWeights</a> (FILE *fp, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#afdcbcfae750035eb2ea8a0142b6f390c">getMediansFromDataTable</a> (<a class="el" href="structDataTable.html">DataTable</a> *data, int ngenes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#ae3804784c7b8995f852f3066129b0284">Rescale</a> (<a class="el" href="structDataTable.html">DataTable</a> *data, double *multipliers, int ngenes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSearchSpace.html">SearchSpace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#ac18ceed02482a28f43930a03215db36d">InitLimits</a> (FILE *fp, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#acaca067ab7508371af477ba56c97e3e9">InitPenalty</a> (FILE *fp, <a class="el" href="structTheProblem.html">TheProblem</a> defs, <a class="el" href="structSearchSpace.html">SearchSpace</a> *limits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGenoType.html">GenoType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a5a290e43263ee3160e54556fa9c7af4e">InitTTs</a> (<a class="el" href="structGenoType.html">GenoType</a> *facttype, int nalleles)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStep__Acc.html">Step_Acc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#ac64c7dfabeacc6eb9023a86a88b1ea7d">InitStepsize</a> (double step, double acc, FILE *slog, char *infile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a14f9123a0d3de0c891e5a5af2470cfcc">Score</a> (<a class="el" href="structInput.html">Input</a> *inp, <a class="el" href="structScoreOutput.html">ScoreOutput</a> *out, int jacobian)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a5782665132610077c6b091d5a8869d3a">Eval</a> (<a class="el" href="structScoreEval.html">ScoreEval</a> *eval, <a class="el" href="structNArrPtr.html">NArrPtr</a> *Solution, int gindex, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a7b04d0994daddf9e32450873f652a8d4">SetGuts</a> (int gutflag, int ndigits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#ae4aef5ccbf247bf86ed151b857301081">GutEval</a> (<a class="el" href="structScoreEval.html">ScoreEval</a> *eval, <a class="el" href="structNArrPtr.html">NArrPtr</a> *Solution, int gindex, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSearchSpace.html">SearchSpace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a4971dd36e85ae350f1a33c89140c7199">GetLimits</a> (<a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a50c060365bd41dfb96b9494f0f6ad50d">DoCalculatePenalty</a> (double param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#ab044b53aa463bcb00191d35ce56c403b">CalculateSinglePenalty</a> (double *param, <a class="el" href="structRange.html">Range</a> **lim, int ncols, double max)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#ae97b1598001ad59907a834ef50efba83">CalculateCompoundPenalty</a> (double *param, <a class="el" href="structRange.html">Range</a> **lim, int nrows, int ncols, double *vmax)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a005757d24b460021d7e4cf78de912cd8">GetPenalty</a> (<a class="el" href="structInput.html">Input</a> *inp, <a class="el" href="structSearchSpace.html">SearchSpace</a> *limits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a60cc95e55d59db00a465f663c4a8f044">GetPenalty_OLD</a> (<a class="el" href="structInput.html">Input</a> *inp, <a class="el" href="structSearchSpace.html">SearchSpace</a> *limits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a597f62551b43cb9ef705f68989dc6a5b">Penalty2Limits</a> (<a class="el" href="structSearchSpace.html">SearchSpace</a> *limits, <a class="el" href="structTheProblem.html">TheProblem</a> defs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataTable.html">DataTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a537940a0eef76df989fc35314ceb4ff6">List2Facts</a> (<a class="el" href="structDlist.html">Dlist</a> *inlist, int ngenes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a0de4c8704919aa70f8657b2073a0ef14">FreeFacts</a> (<a class="el" href="structDataTable.html">DataTable</a> *D)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInterpObject.html">InterpObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_8c.html#a72a51a0c1ac5b405e85ec70432687325">InitHistory</a> (FILE *fp, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01fa6c9543763a97497d3cc1b5256dba"></a><!-- doxytag: member="score.c::GetInterp" ref="a01fa6c9543763a97497d3cc1b5256dba" args="(FILE *fp, char *title, Input *inp, int num_genes, DataTable **interp_tables)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetInterp</b> (FILE *fp, char *title, <a class="el" href="structInput.html">Input</a> *inp, int num_genes, <a class="el" href="structDataTable.html">DataTable</a> **interp_tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aada84dacfd72b84ae781672218208662"></a><!-- doxytag: member="score.c::FreeHistory" ref="aada84dacfd72b84ae781672218208662" args="(int nalleles, InterpObject *polations)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>FreeHistory</b> (int nalleles, <a class="el" href="structInterpObject.html">InterpObject</a> *polations)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6e120054b9f3a361ed43e89dff1a4b"></a><!-- doxytag: member="score.c::FreeExternalInputs" ref="a1f6e120054b9f3a361ed43e89dff1a4b" args="(int nalleles, InterpObject *extinp_polations)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>FreeExternalInputs</b> (int nalleles, <a class="el" href="structInterpObject.html">InterpObject</a> *extinp_polations)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a3c67fbfa03e0c395046436f0d37c23"></a><!-- doxytag: member="score.c::InitExternalInputs" ref="a2a3c67fbfa03e0c395046436f0d37c23" args="(FILE *fp, Input *inp)" -->
<a class="el" href="structInterpObject.html">InterpObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>InitExternalInputs</b> (FILE *fp, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9761dbe265018387b77b36a39cd4b59"></a><!-- doxytag: member="score.c::initResComp" ref="ae9761dbe265018387b77b36a39cd4b59" args="(NArrPtr inData)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>initResComp</b> (<a class="el" href="structNArrPtr.html">NArrPtr</a> inData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1bd4656a3cbbeb7937007f604465850"></a><!-- doxytag: member="score.c::isResComp" ref="ac1bd4656a3cbbeb7937007f604465850" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>isResComp</b> ()</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa065f30aa9f5f9a42132c82c787ee70b"></a><!-- doxytag: member="score.c::fp" ref="aa065f30aa9f5f9a42132c82c787ee70b" args="" -->
FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fp</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30dfaef4d7b27aee669304c1b7a41f16"></a><!-- doxytag: member="score.c::gutparms" ref="a30dfaef4d7b27aee669304c1b7a41f16" args="" -->
<a class="el" href="structGutInfo.html">GutInfo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>gutparms</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba03789931e4728cf761c0a156e28325"></a><!-- doxytag: member="score.c::best_score" ref="aba03789931e4728cf761c0a156e28325" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>best_score</b> = 2000000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee3dc5358037a9ee4c1be8f0d07dbd09"></a><!-- doxytag: member="score.c::SLEEP_LGTH" ref="aee3dc5358037a9ee4c1be8f0d07dbd09" args="" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>SLEEP_LGTH</b> = 2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94087ddaa6251837c08fcfd59a4ded74"></a><!-- doxytag: member="score.c::NPOINTS" ref="a94087ddaa6251837c08fcfd59a4ded74" args="" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>NPOINTS</b> = 50</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Function implementation for reading and defining facts/limits, and for scoring. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>JR, modified by Yoginho, scoregut functions by Yousong Wang in June 2002</dd></dl>
<p>Copyright (C) 1989-2003 John Reinitz, 2009-2013 Damjan Cicin-Sain, Anton Crombach and Yogi Jaeger</p>
<p>The functions defined here initialize or manipulate facts or data time tables, read and initialize limits and penalty (if needed) and do the actual scoring by least squares. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae97b1598001ad59907a834ef50efba83"></a><!-- doxytag: member="score.c::CalculateCompoundPenalty" ref="ae97b1598001ad59907a834ef50efba83" args="(double *param, Range **lim, int nrows, int ncols, double *vmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CalculateCompoundPenalty </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRange.html">Range</a> **&nbsp;</td>
          <td class="paramname"> <em>lim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate penalties for a matrix parameter, like T_h, T_b, E_h, E_b </p>

</div>
</div>
<a class="anchor" id="ab044b53aa463bcb00191d35ce56c403b"></a><!-- doxytag: member="score.c::CalculateSinglePenalty" ref="ab044b53aa463bcb00191d35ce56c403b" args="(double *param, Range **lim, int ncols, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CalculateSinglePenalty </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRange.html">Range</a> **&nbsp;</td>
          <td class="paramname"> <em>lim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate penalties for a simple parameter, like R, m, h, d, lambda </p>

</div>
</div>
<a class="anchor" id="a50c060365bd41dfb96b9494f0f6ad50d"></a><!-- doxytag: member="score.c::DoCalculatePenalty" ref="a50c060365bd41dfb96b9494f0f6ad50d" args="(double param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DoCalculatePenalty </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Experimental feature: how to calculate penalties in the new model </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Anton Crombach </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2012, August </dd></dl>

</div>
</div>
<a class="anchor" id="a5782665132610077c6b091d5a8869d3a"></a><!-- doxytag: member="score.c::Eval" ref="a5782665132610077c6b091d5a8869d3a" args="(ScoreEval *eval, NArrPtr *Solution, int gindex, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structScoreEval.html">ScoreEval</a> *&nbsp;</td>
          <td class="paramname"> <em>eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNArrPtr.html">NArrPtr</a> *&nbsp;</td>
          <td class="paramname"> <em>Solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Eval: scores the summed squared differences between equation solution and data. Because the times for states written to the Solution structure are read out of the data file itself, we do not check for consistency of times in this function---all times with data will be in the table, but the table may also contain additional times. </p>

</div>
</div>
<a class="anchor" id="a0de4c8704919aa70f8657b2073a0ef14"></a><!-- doxytag: member="score.c::FreeFacts" ref="a0de4c8704919aa70f8657b2073a0ef14" args="(DataTable *D)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeFacts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDataTable.html">DataTable</a> *&nbsp;</td>
          <td class="paramname"> <em>D</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>FreeFacts: Function to fre tha <a class="el" href="structDataTable.html" title="Store facts data.">DataTable</a> object </p>

</div>
</div>
<a class="anchor" id="a99d47fb9d05f4c80bee60a346c47ffdc"></a><!-- doxytag: member="score.c::getFact" ref="a99d47fb9d05f4c80bee60a346c47ffdc" args="(int i, GenoType *facttype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataTable.html">DataTable</a> getFact </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGenoType.html">GenoType</a> *&nbsp;</td>
          <td class="paramname"> <em>facttype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getFacts: gets facts records from the appropriate <a class="el" href="structDataTable.html" title="Store facts data.">DataTable</a>. Returns a pointer to a <a class="el" href="structFacts.html" title="Just groups the two facts arrays.">Facts</a> structure, which contains a <a class="el" href="structDataTable.html" title="Store facts data.">DataTable</a>, which in turn points to a sized array of DataRecords, one for each time step. </p>

</div>
</div>
<a class="anchor" id="a4971dd36e85ae350f1a33c89140c7199"></a><!-- doxytag: member="score.c::GetLimits" ref="a4971dd36e85ae350f1a33c89140c7199" args="(Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSearchSpace.html">SearchSpace</a>* GetLimits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>GetLimits: returns a pointer to the static limits struct in <a class="el" href="score_8c.html" title="Function implementation for reading and defining facts/limits, and for scoring.">score.c</a> CAUTION: InitScoring must be called first! </p>

</div>
</div>
<a class="anchor" id="afdcbcfae750035eb2ea8a0142b6f390c"></a><!-- doxytag: member="score.c::getMediansFromDataTable" ref="afdcbcfae750035eb2ea8a0142b6f390c" args="(DataTable *data, int ngenes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* getMediansFromDataTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDataTable.html">DataTable</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ngenes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getMediansFromDataTable: Function to calculate medians per gene from data </p>

</div>
</div>
<a class="anchor" id="a005757d24b460021d7e4cf78de912cd8"></a><!-- doxytag: member="score.c::GetPenalty" ref="a005757d24b460021d7e4cf78de912cd8" args="(Input *inp, SearchSpace *limits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetPenalty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSearchSpace.html">SearchSpace</a> *&nbsp;</td>
          <td class="paramname"> <em>limits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>GetPenalty: calculates penalty from static limits, vmax and mmax CAUTION: InitPenalty must be called first! </p>

</div>
</div>
<a class="anchor" id="a60cc95e55d59db00a465f663c4a8f044"></a><!-- doxytag: member="score.c::GetPenalty_OLD" ref="a60cc95e55d59db00a465f663c4a8f044" args="(Input *inp, SearchSpace *limits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetPenalty_OLD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSearchSpace.html">SearchSpace</a> *&nbsp;</td>
          <td class="paramname"> <em>limits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>GetPenalty_OLD: calculates penalty from static limits, vmax and mmax CAUTION: InitPenalty must be called first! </p>

</div>
</div>
<a class="anchor" id="ae4aef5ccbf247bf86ed151b857301081"></a><!-- doxytag: member="score.c::GutEval" ref="ae4aef5ccbf247bf86ed151b857301081" args="(ScoreEval *eval, NArrPtr *Solution, int gindex, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GutEval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structScoreEval.html">ScoreEval</a> *&nbsp;</td>
          <td class="paramname"> <em>eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNArrPtr.html">NArrPtr</a> *&nbsp;</td>
          <td class="paramname"> <em>Solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>GutEval: this is the same as Eval, i.e it calculates the summed squa- red differences between equation solution and data, with the addition that individual squared differences between data- points are written to STDOUT in the unfold output format </p>

</div>
</div>
<a class="anchor" id="a5a0111317ff208d650540857c1cc1675"></a><!-- doxytag: member="score.c::InitFacts" ref="a5a0111317ff208d650540857c1cc1675" args="(FILE *fp, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFacts.html">Facts</a> InitFacts </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitFacts: puts facts records into the appropriate <a class="el" href="structDataTable.html" title="Store facts data.">DataTable</a>. Returns a pointer to a <a class="el" href="structFacts.html" title="Just groups the two facts arrays.">Facts</a> struture, which contains a Datatable, which in turn points to a sized array of DataRecords, one for each time step. </p>

</div>
</div>
<a class="anchor" id="a72a51a0c1ac5b405e85ec70432687325"></a><!-- doxytag: member="score.c::InitHistory" ref="a72a51a0c1ac5b405e85ec70432687325" args="(FILE *fp, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInterpObject.html">InterpObject</a>* InitHistory </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitHistory: Initializing the full set of nuclei based on the lineages of the history, please make sure that all of the alleles' lineages are the same </p>

</div>
</div>
<a class="anchor" id="ac18ceed02482a28f43930a03215db36d"></a><!-- doxytag: member="score.c::InitLimits" ref="ac18ceed02482a28f43930a03215db36d" args="(FILE *fp, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSearchSpace.html">SearchSpace</a>* InitLimits </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitLimits: reads limits section from the data file into the struct limits, which is static to <a class="el" href="score_8c.html" title="Function implementation for reading and defining facts/limits, and for scoring.">score.c</a>. Then, it initializes the penalty function if necessary. NOTE: lambda limits are stored as protein half lives in the data file and therefore get converted upon reading </p>

</div>
</div>
<a class="anchor" id="acaca067ab7508371af477ba56c97e3e9"></a><!-- doxytag: member="score.c::InitPenalty" ref="acaca067ab7508371af477ba56c97e3e9" args="(FILE *fp, TheProblem defs, SearchSpace *limits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InitPenalty </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTheProblem.html">TheProblem</a>&nbsp;</td>
          <td class="paramname"> <em>defs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSearchSpace.html">SearchSpace</a> *&nbsp;</td>
          <td class="paramname"> <em>limits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitPenalty: initializes vmax[] and mmax static to <a class="el" href="score_8c.html" title="Function implementation for reading and defining facts/limits, and for scoring.">score.c</a>; these variables are used to calculate the penalty function for scoring. NOTE: Should only get called, if penalty function is used </p>

</div>
</div>
<a class="anchor" id="aa8cf2f048908ec245bd5832dfb76e5ae"></a><!-- doxytag: member="score.c::InitScoring" ref="aa8cf2f048908ec245bd5832dfb76e5ae" args="(FILE *fp, int method, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structScoring.html">Scoring</a> InitScoring </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitScoring: intializes a) facts-related structs and TTimes and b) parameter ranges for the Score function. </p>

</div>
</div>
<a class="anchor" id="ac64c7dfabeacc6eb9023a86a88b1ea7d"></a><!-- doxytag: member="score.c::InitStepsize" ref="ac64c7dfabeacc6eb9023a86a88b1ea7d" args="(double step, double acc, FILE *slog, char *infile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStep__Acc.html">Step_Acc</a> InitStepsize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>infile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitStepsize: the only thing this function does is putting stepsize and accuracy in a structure to be passed to the solver by the <a class="el" href="score_8c.html#a14f9123a0d3de0c891e5a5af2470cfcc">Score()</a> function </p>

</div>
</div>
<a class="anchor" id="a5a290e43263ee3160e54556fa9c7af4e"></a><!-- doxytag: member="score.c::InitTTs" ref="a5a290e43263ee3160e54556fa9c7af4e" args="(GenoType *facttype, int nalleles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGenoType.html">GenoType</a>* InitTTs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGenoType.html">GenoType</a> *&nbsp;</td>
          <td class="paramname"> <em>facttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nalleles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitTTs: Initializes the time points for which we need model output i.e. the time points for which we have data. NOTE: we do not allow data at t=0 but it still gets included into TTs </p>

</div>
</div>
<a class="anchor" id="a5062990a4365a5c5e5f4926691177e3c"></a><!-- doxytag: member="score.c::InitTweak" ref="a5062990a4365a5c5e5f4926691177e3c" args="(FILE *fp, int *mask, TheProblem defs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTweak.html">Tweak</a> InitTweak </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTheProblem.html">TheProblem</a>&nbsp;</td>
          <td class="paramname"> <em>defs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitTweak: installs tweak as a static variable in <a class="el" href="translate_8c.html" title="Makes the list of pointers that the annealer uses to make moves.">translate.c</a>; tweak is read from the $tweak section in newstyle data files </p>

</div>
</div>
<a class="anchor" id="a76abc0d14c58dd765039064041f0b62c"></a><!-- doxytag: member="score.c::InitWeights" ref="a76abc0d14c58dd765039064041f0b62c" args="(FILE *fp, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structWeights.html">Weights</a> InitWeights </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>InitWeights: puts facts records into the appropriate <a class="el" href="structDataTable.html" title="Store facts data.">DataTable</a>. Returns a pointer to a <a class="el" href="structDataTable.html" title="Store facts data.">DataTable</a>, which in turn points to a sized array of DataRecords </p>

</div>
</div>
<a class="anchor" id="a537940a0eef76df989fc35314ceb4ff6"></a><!-- doxytag: member="score.c::List2Facts" ref="a537940a0eef76df989fc35314ceb4ff6" args="(Dlist *inlist, int ngenes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataTable.html">DataTable</a>* List2Facts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDlist.html">Dlist</a> *&nbsp;</td>
          <td class="paramname"> <em>inlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ngenes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List2Facts: takes a <a class="el" href="structDlist.html" title="linked list used to read bias &amp; facts">Dlist</a> and returns the corresponding <a class="el" href="structDataTable.html" title="Store facts data.">DataTable</a> structure we use for facts data.</p>
<p>An extensive comment about indices: (by JJ)</p>
<p>All data points with -1 as a value are NOT read from the data file. The difference between such ignored and zero values is crucial: -1 data points WILL NOT BE COMPARED TO simulation data, whereas 0 means NO PROTEIN AT THAT TIME IN THAT NUCLEUS. Index numbers help maintain the integrity of the data. An index number is defined as the array index at which a protein concentration would be if the data was complete, i.e. available for all nuclei at all times. In this way a sparse set of data can be compared to a complete set of simulation output. Thus, indices are defined as starting from 1 for each <a class="el" href="structDataRecord.html" title="Store facts data.">DataRecord</a> (each time step) and increase by one for each gene in each nucleus in the order predefined by JR. </p>

</div>
</div>
<a class="anchor" id="a597f62551b43cb9ef705f68989dc6a5b"></a><!-- doxytag: member="score.c::Penalty2Limits" ref="a597f62551b43cb9ef705f68989dc6a5b" args="(SearchSpace *limits, TheProblem defs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Penalty2Limits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSearchSpace.html">SearchSpace</a> *&nbsp;</td>
          <td class="paramname"> <em>limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTheProblem.html">TheProblem</a>&nbsp;</td>
          <td class="paramname"> <em>defs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Penalty2Limits: uses the inverse function of g(u) to calculate upper and lower limits for T, m and h using the penalty lambda parameter; these limits can only be an appro- ximation, since all T, m and h are added up to yield u for g(u); we try to compensate for this summation dividing the limits by sqrt(n); this function then sets the penalty vector to NULL and supplies explicit limits for T, m and h, which can be used for scram- bling parameters and such CAUTION: this func DOES NOT RESET pen_vec, caller must do this</p>
<p>A short comment on penalty limits (JJ, Aug 7, 2001):</p>
<p>In order to produce random values of T, m and h that are within reasonable limits when no explicit limits are used for them, we do the following approximation:</p>
<p>First, we determine the limits of u in g(u) within which there is no penalty assigned. This is true for all g(u) be- tween Lambda and (1-Lambda). Therefore, we calculate the in- verse function of g(u) for those to values to get upper and lower limits for u (based on ideas by Eric Mjolsness). Since we need to sum up all T * vmax, m * mmax and h to get u, we'll compensate by dividing the limits by the sqrt of the number of genes in the problem. This way we think, we'll get reasonable limits for single parameters (idea by JR). All the above happens in the Penalty2Limits function in sco- re.c. When comparing parameters to limits, don't forget to multiply Ts with vmax and ms with mmax. This happens in main of scramble below. hs are compared as they are. See JJs lab notes for further detail on g(u)-inverse and such. </p>

</div>
</div>
<a class="anchor" id="ae3804784c7b8995f852f3066129b0284"></a><!-- doxytag: member="score.c::Rescale" ref="ae3804784c7b8995f852f3066129b0284" args="(DataTable *data, double *multipliers, int ngenes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rescale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDataTable.html">DataTable</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>multipliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ngenes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rescale: Function to rescale data - for every gene multiply data per previously calculated multiplier </p>

</div>
</div>
<a class="anchor" id="a14f9123a0d3de0c891e5a5af2470cfcc"></a><!-- doxytag: member="score.c::Score" ref="a14f9123a0d3de0c891e5a5af2470cfcc" args="(Input *inp, ScoreOutput *out, int jacobian)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Score </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structScoreOutput.html">ScoreOutput</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>jacobian</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Score: as the name says, score runs the simulation, gets a solution and then compares it to the data using the Eval least squares function NOTE: both InitZygote and InitScoring have to be called first! </p>

</div>
</div>
<a class="anchor" id="a7b04d0994daddf9e32450873f652a8d4"></a><!-- doxytag: member="score.c::SetGuts" ref="a7b04d0994daddf9e32450873f652a8d4" args="(int gutflag, int ndigits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetGuts </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gutflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndigits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SetGuts: sets the gut info in <a class="el" href="score_8c.html" title="Function implementation for reading and defining facts/limits, and for scoring.">score.c</a> for printing out guts </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2013 for SimAnn by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
