<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SimAnn: fly/solvers.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>fly/solvers.c File Reference</h1>
<p>Contains the solver function implementations (can be toggled by -s option) that propagate the equations.  
<a href="#_details">More...</a></p>
<code>#include &lt;float.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="error_8h_source.html">error.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="solvers_8h_source.html">solvers.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="maternal_8h_source.html">maternal.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="zygotic_8h_source.html">zygotic.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="integrate_8h_source.html">integrate.h</a>&gt;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3c80caa06171d7fad9ab72cb3c9cd5b"></a><!-- doxytag: member="solvers.c::DSQR" ref="aa3c80caa06171d7fad9ab72cb3c9cd5b" args="(a)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DSQR</b>(a)&nbsp;&nbsp;&nbsp;((dqrarg=(a)) == 0.0 ? 0.0 : dqrarg*dqrarg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DMAX</b>(a, b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DMIN</b>(a, b)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#ae8016a49c971f7f973663bcfd6921dbb">Euler</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a270ab0adff5052cf4e1da796c23d99c4">Meuler</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a97e03e6ff4dc28c1fa9882e09b30d59c">Heun</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#aa769d6b7f7c138e8c659a7e7b1a256da">Rk2</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#af811314e3f811a04f9dfc54a3368d359">Rk4</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a22d1585560a34951ee703468643de616">Rkck</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a6087b8c0ab5c1170a4e3000289f7e7ea">Rkf</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a38d2c4e212d863c00c4275a5867287aa">Milne</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#aa20e5e9f5c0b7807c310cbe0444e96f7">Adams</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a5135579c74007c279b00970d4bf23a01">BuSt</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#ac9521dec953badfb45f871e51fd8cb21">bsstep</a> (double *v, double *deriv, int n, double *t, double htry, double accuracy, double *hdid, double *hnext, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#ab7e5ce78d2e46e527abbbfcfbddef1a0">pzextr</a> (int iest, double hest, double *vest, double *vout, double *dv, int n, const int KMAXX)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#afc6326c0188c57c40b82a8e8977ba3d9">mmid</a> (double *vin, double *vout, double *deriv, double tin, double htot, int nstep, int n, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a121e2c55a5a00a0ad9b953ee654cde08">BaDe</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a84cf8f0168e075e49d7d383ffd9efc1e">stifbs</a> (double *v, double *deriv, int n, double *t, double htry, double accuracy, double *hdid, double *hnext, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a2704a4f583549482cb8f64b9b5b9897d">simpr</a> (double *vin, double *vout, double *deriv, double *dfdt, double **jac, double tin, double htot, int nstep, int n, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#aec72c11d5bed935ceab70026dabea1ac">ludcmp</a> (double **a, int n, int *indx, double *d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a2f383ce6542557020a572bac16e77055">lubksb</a> (double **a, int n, int *indx, double *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#aa9f4951e44339690c0b36fcb131e25d6">WriteSolvLog</a> (char *solver, double tin, double tout, double h, int n, int nderivs, FILE *slog)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a4a45ad1ee998bd642e3adf4ae72f5f1c">SoDe</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ba009b4c4a756295032d2d2c629846e"></a><!-- doxytag: member="solvers.c::compare" ref="a0ba009b4c4a756295032d2d2c629846e" args="(double *x, double *y)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compare</b> (double *x, double *y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25482a4d9598a01c466c4656cc05ce4c"></a><!-- doxytag: member="solvers.c::Construct_Discont_Array" ref="a25482a4d9598a01c466c4656cc05ce4c" args="(double range, double *taus, int n, double *starts, int sn, int *disc_size)" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>Construct_Discont_Array</b> (double range, double *taus, int n, double *starts, int sn, int *disc_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e284fa03cc0d813a3817fce38b3767d"></a><!-- doxytag: member="solvers.c::CE" ref="a2e284fa03cc0d813a3817fce38b3767d" args="(double t, double *vans, double tbegin, double *v_at_tbegin, double ech, double *d1, double *d2, double *d3, double *d4, int n)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CE</b> (double t, double *vans, double tbegin, double *v_at_tbegin, double ech, double *d1, double *d2, double *d3, double *d4, int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac12e37840909f894220d2cd7e3c96e9"></a><!-- doxytag: member="solvers.c::y_delayed" ref="aac12e37840909f894220d2cd7e3c96e9" args="(double ***vd, int n, double *rktimes, double *tau, double *grid, double **vdone, double **deriv1, double **deriv2, double **deriv3, double **deriv4, int gridsize, double accu, SolverInput *si, Input *inp)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>y_delayed</b> (double ***vd, int n, double *rktimes, double *tau, double *grid, double **vdone, double **deriv1, double **deriv2, double **deriv3, double **deriv4, int gridsize, double accu, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a4be37b339afa64593767489d8d46c746">DCERk32</a> (double **vatt, int n, double *tarray, int tpoints, double *darray, int dpoints, double stephint, double accuracy, <a class="el" href="structSolverInput.html">SolverInput</a> *si, <a class="el" href="structInput.html">Input</a> *inp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62c54ac649fb756dfe1449fe97997ea4"></a><!-- doxytag: member="solvers.c::FreeDelaySolver" ref="a62c54ac649fb756dfe1449fe97997ea4" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>FreeDelaySolver</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28d5f0f1bac4fe188f5162c736d1cfff"></a><!-- doxytag: member="solvers.c::InitDelaySolver" ref="a28d5f0f1bac4fe188f5162c736d1cfff" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InitDelaySolver</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a283a82ba094e935a7df59ab28372d64e"></a><!-- doxytag: member="solvers.c::DivideHistory" ref="a283a82ba094e935a7df59ab28372d64e" args="(double t1, double t2, Zygote *zyg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DivideHistory</b> (double t1, double t2, <a class="el" href="structZygote.html">Zygote</a> *zyg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#a0adb937524dd2a86627683c4eb9681df">InitKrylovVariables</a> (double *vin, int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b2523b3f0a227d17e730290afde692f"></a><!-- doxytag: member="solvers.c::CheckFlag" ref="a7b2523b3f0a227d17e730290afde692f" args="(void *flagvalue, char *funcname, int opt)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CheckFlag</b> (void *flagvalue, char *funcname, int opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#af374eadd949ee5ba6cad68118524867f">Krylov</a> (double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, <a class="el" href="structSolverInput.html">SolverInput</a> *sinput, <a class="el" href="structInput.html">Input</a> *input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#aea41aa29042230e96f756b96180271cd">my_f_band</a> (realtype t, N_Vector y, N_Vector ydot, void *extra_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a655b3c9db3a10fcc5997e7e858d8f41d"></a><!-- doxytag: member="solvers.c::InitBandSolver" ref="a655b3c9db3a10fcc5997e7e858d8f41d" args="(realtype tzero, double stephint, double rel_tol, double abs_tol)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>InitBandSolver</b> (realtype tzero, double stephint, double rel_tol, double abs_tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a605fb06d99c427905ed98deb79d19618"></a><!-- doxytag: member="solvers.c::FreeBandSolver" ref="a605fb06d99c427905ed98deb79d19618" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>FreeBandSolver</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="solvers_8c.html#ae5bd7dd5efc4acce68f8b2adb32ec6d4">writeInfo</a> ()</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6261d15419eb591b3f65c5f8cd7b8cb"></a><!-- doxytag: member="solvers.c::d" ref="ae6261d15419eb591b3f65c5f8cd7b8cb" args="" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>d</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312c83bcf7a6bf886904f0edc0ceced0"></a><!-- doxytag: member="solvers.c::hpoints" ref="a312c83bcf7a6bf886904f0edc0ceced0" args="" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>hpoints</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a128c54b7f4edabe013eaef729c0f0a21"></a><!-- doxytag: member="solvers.c::maxdel" ref="a128c54b7f4edabe013eaef729c0f0a21" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>maxdel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4254f455868d4946f1b13de21452ec4d"></a><!-- doxytag: member="solvers.c::mindel" ref="a4254f455868d4946f1b13de21452ec4d" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>mindel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8048c2b1bbb551e65dd36304ccfbb311"></a><!-- doxytag: member="solvers.c::numdel" ref="a8048c2b1bbb551e65dd36304ccfbb311" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>numdel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab002e689b75fd56a1df4e6573f596237"></a><!-- doxytag: member="solvers.c::gridstart" ref="ab002e689b75fd56a1df4e6573f596237" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>gridstart</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a692f69dfdc1f1e6215e6c447d7a8623e"></a><!-- doxytag: member="solvers.c::delay" ref="a692f69dfdc1f1e6215e6c447d7a8623e" args="" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>delay</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d1a83459345b13e5e76fe3fe247d3e1"></a><!-- doxytag: member="solvers.c::gridpos" ref="a7d1a83459345b13e5e76fe3fe247d3e1" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>gridpos</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba42da318b9d388e73f1095675933a2d"></a><!-- doxytag: member="solvers.c::tdone" ref="aba42da318b9d388e73f1095675933a2d" args="" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>tdone</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78d912f6bd315c74b89a55eeaf0224fe"></a><!-- doxytag: member="solvers.c::derivv1" ref="a78d912f6bd315c74b89a55eeaf0224fe" args="" -->
double **&nbsp;</td><td class="memItemRight" valign="bottom"><b>derivv1</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8c0159a6419e422738055e0dcfbaede"></a><!-- doxytag: member="solvers.c::derivv2" ref="ab8c0159a6419e422738055e0dcfbaede" args="" -->
double **&nbsp;</td><td class="memItemRight" valign="bottom"><b>derivv2</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9d2eb64f571f82d95fb3ce54cfe2909"></a><!-- doxytag: member="solvers.c::derivv3" ref="ae9d2eb64f571f82d95fb3ce54cfe2909" args="" -->
double **&nbsp;</td><td class="memItemRight" valign="bottom"><b>derivv3</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9de08945b3b017f399f3513d4cba218c"></a><!-- doxytag: member="solvers.c::derivv4" ref="a9de08945b3b017f399f3513d4cba218c" args="" -->
double **&nbsp;</td><td class="memItemRight" valign="bottom"><b>derivv4</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91158b5f3384965c57166629f062e96f"></a><!-- doxytag: member="solvers.c::vdonne" ref="a91158b5f3384965c57166629f062e96f" args="" -->
double **&nbsp;</td><td class="memItemRight" valign="bottom"><b>vdonne</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2df434836dc68419371bf9bd2a830e88"></a><!-- doxytag: member="solvers.c::dqrarg" ref="a2df434836dc68419371bf9bd2a830e88" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>dqrarg</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Contains the solver function implementations (can be toggled by -s option) that propagate the equations. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>JR, modified by Yoginho, Additional solvers by: Joel Linton (Rk4), Johannes Jaeger (Rk2, Meuler, Heun), Konstantin Kozlov (Milne, Adams), Marcel Wolf (Rkck, Rkf), Manu (Adams, BuSt), Anton Crombach (Krylov)</dd></dl>
<p>Copyright (C) 1989-2003 John Reinitz, 2009-2013 Damjan Cicin-Sain, Anton Crombach and Yogi Jaeger</p>
<dl class="note"><dt><b>Note:</b></dt><dd><em>ONLY</em> general solvers allowed here; they <em>MUST</em> comply to the generic solver interface</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The functions in this file return vin and vout unchanged iff stepsize = 0. It is the responsibility of the calling function to be sure that this is not a problem.</dd></dl>
<dl class="user"><dt><b>Usage:</b></dt><dd></dd></dl>
<p>All solvers adhere to the same interface:</p>
<p>Solver(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n);</p>
<p>Arguments:</p>
<ul>
<li>vin array of dependent variables at 'tin' (start)</li>
<li>vout array of dependent variables at 'tout' (end); this is what's returned by the solver</li>
<li>tin time at start</li>
<li>tout time at end</li>
<li>stephint suggested stepsize for fixed stepsize solvers; see extensive comment below; the embedded Rk solvers (Rkck, Rkf) take stephint as their ini- tial stepsize</li>
<li>accuracy accuracy for adaptive stepsize solvers; accuracy is always relative, i.e. 0.1 means 10% of the actual v we've evaluated</li>
<li>n size of vin and vout arrays; the user is respon- sible for checking that the number of elements does not change in the model between vin/vout</li>
</ul>
<p>Note that if tin = tout the solvers will just returns with- out doing anything. The caller is responsible for handling such a situation.</p>
<dl class="user"><dt><b>Solver Naming Conventions: </b></dt><dd></dd></dl>
<p>There are various contradictory solver nomenclatures in the literature. If not stated otherwise, we use the ones from the following two books, on which most of our solvers are based:</p>
<p>Press, Teukolsky, Vetterling &amp; Flannery (1992). Numerical Recipes in C. Cambridge University Press, Cambridge, U.K.</p>
<p>Burden &amp; Faires (1993). Numerical Analysis, 5th Edition. PWS Publishing Co., Boston MA, U.S.A.</p>
<dl class="user"><dt><b>Important Comment: </b></dt><dd></dd></dl>
<p>stephint and the stepsize of fixed-stepsize solvers:</p>
<p>The stepsize which is passed to a fixed-stepsize solvers is actually a stephint, i.e. only an approximation to the actual stepsize which depends on the length of the interval over which the equations are propagated:</p>
<p>if the remainder of (deltat div stephint) is:</p>
<p>0 stepsize = stephint &gt; 0 &amp;&amp; &lt; stephint/2 stepsize &gt; stephint &gt;= stephint/2 &amp;&amp; &lt; stephint stepsize &lt; stephint</p>
<p>The exact amount of the difference between stepsize and step- hint depends on the size of deltat and stephint:</p>
<ul>
<li>the larger deltat, the smaller the maximum possible diffe- rence for a given stephint</li>
<li>the larger stephint, the larger the maximum possible di- fference for a given stephint</li>
</ul>
<p>Since mitoses only last about 3-5 minutes, these differences are quite significant for large stepsizes ( &gt; 0.1 ). For the 4div schedule (newstyle datafiles) we have maximum relative differences between stephint and actual stepsize of about:</p>
<p>stephint max. rel. difference</p>
<p>1.0 10.0% 0.5 5.8% 0.3 4.3% 0.1 1.0%</p>
<p>See ../doc/step4div.ps for more details. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a336369f90a614345170f9eb3d4ef59e6"></a><!-- doxytag: member="solvers.c::DMAX" ref="a336369f90a614345170f9eb3d4ef59e6" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAX</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(dmaxarg1 = (a), dmaxarg2 = (b), (dmaxarg1) &gt; \
(dmaxarg2) ?  (dmaxarg1) : (dmaxarg2))
</pre></div>
</div>
</div>
<a class="anchor" id="af9a0a96e48b21c87d05acd4ed5117ba0"></a><!-- doxytag: member="solvers.c::DMIN" ref="af9a0a96e48b21c87d05acd4ed5117ba0" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMIN</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(dminarg1 = (a), dminarg2 = (b), (dminarg1) &lt; \
(dminarg2) ?  (dminarg1) : (dminarg2))
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa20e5e9f5c0b7807c310cbe0444e96f7"></a><!-- doxytag: member="solvers.c::Adams" ref="aa20e5e9f5c0b7807c310cbe0444e96f7" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adams </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adams: propagates vin (of size n) from tin to tout by Adams-Moulton which is an implicit predictor-corrector method of second order; the result is returned by vout</p>
<p>This solver was implemented by Konstantin Koslov, Spring 2002 Slightly modified by Manu, July 2002 </p>

</div>
</div>
<a class="anchor" id="a121e2c55a5a00a0ad9b953ee654cde08"></a><!-- doxytag: member="solvers.c::BaDe" ref="a121e2c55a5a00a0ad9b953ee654cde08" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaDe </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>BaDe: propagates v(t) from t1 to t2 by Bader-Deuflhard; this method uses Richardson extrapolation to estimate v's at a hypothe- tical stepsize of 0; the extrapolation also yields an error estimate, which is used to adapt stepsize and change the or- der of the method as required; the result is returned by vout</p>
<p>This solver was implemented by Yogi, based on BuSt, Aug 2002 </p>

</div>
</div>
<a class="anchor" id="ac9521dec953badfb45f871e51fd8cb21"></a><!-- doxytag: member="solvers.c::bsstep" ref="ac9521dec953badfb45f871e51fd8cb21" args="(double *v, double *deriv, int n, double *t, double htry, double accuracy, double *hdid, double *hnext, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bsstep </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>htry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>hdid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>hnext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>bsstep: this is the Bulirsch-Stoer stepper function; it propagates the equations at a given overall stepsize and order, then evaluates the error and repeats the step with increased order if necessary, until the required accuracy is achieved; its arguments are:</p>
<ul>
<li>v: input and output v's over a give total stepsize</li>
<li>deriv: array of initial derivatives (at tin)</li>
<li>n: size of v and deriv</li>
<li>t: pointer to the current time</li>
<li>htry: initial stepsize to be tried</li>
<li>accuracy: relative accuracy to be achieved</li>
<li>hdid: returns the stepsize of the step we just did</li>
<li>hnext: returns the stepsize of the next step to be done </li>
</ul>

</div>
</div>
<a class="anchor" id="a5135579c74007c279b00970d4bf23a01"></a><!-- doxytag: member="solvers.c::BuSt" ref="a5135579c74007c279b00970d4bf23a01" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BuSt </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>BuSt: propagates v(t) from t1 to t2 by Bulirsch-Stoer; this method uses Richardson extrapolation to estimate v's at a hypothe- tical stepsize of 0; the extrapolation also yields an error estimate, which is used to adapt stepsize and change the or- der of the method as required; the result is returned by vout</p>
<p>This solver was implemented by Manu, July 2002 </p>

</div>
</div>
<a class="anchor" id="a4be37b339afa64593767489d8d46c746"></a><!-- doxytag: member="solvers.c::DCERk32" ref="a4be37b339afa64593767489d8d46c746" args="(double **vatt, int n, double *tarray, int tpoints, double *darray, int dpoints, double stephint, double accuracy, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCERk32 </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>vatt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>tarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>darray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DCERk3(2): propagates v[0] (of size n) according to tarray by the Runge-Kutta 3(2) pair with continuous extension storing the result in vatt. Initial conditions are specified in vatt[0], corresponding to tarray[0] </p>

<p><p>used for storing intermediate steps </p>
</p>

</div>
</div>
<a class="anchor" id="ae8016a49c971f7f973663bcfd6921dbb"></a><!-- doxytag: member="solvers.c::Euler" ref="ae8016a49c971f7f973663bcfd6921dbb" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Euler: propagates vin (of size n) from tin to tout by the Euler method; the result is returned by vout </p>

</div>
</div>
<a class="anchor" id="a97e03e6ff4dc28c1fa9882e09b30d59c"></a><!-- doxytag: member="solvers.c::Heun" ref="a97e03e6ff4dc28c1fa9882e09b30d59c" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Heun </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Heun: propagates vin (of size n) from tin to tout by Heun's method the result is returned by vout </p>

</div>
</div>
<a class="anchor" id="a0adb937524dd2a86627683c4eb9681df"></a><!-- doxytag: member="solvers.c::InitKrylovVariables" ref="a0adb937524dd2a86627683c4eb9681df" args="(double *vin, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InitKrylovVariables </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Krylov: propagates vin (of size n) from tin to tout by BDF (Backward * Differential Formulas and use of a Newton-Krylov method with * preconditioning to avoid the costly computation of the * jacobian. *</p>
<p>* This solver was written by Anton Crombach, October 2010 * * </p>

</div>
</div>
<a class="anchor" id="af374eadd949ee5ba6cad68118524867f"></a><!-- doxytag: member="solvers.c::Krylov" ref="af374eadd949ee5ba6cad68118524867f" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *sinput, Input *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Krylov </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>sinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>input</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Krylov: propagates vin (of size n) from tin to tout by BDF (Backward Differential Formulas and use of a Newton-Krylov method with preconditioning to avoid the costly computation of the jacobian.</p>
<p>This solver was written by Anton Crombach, October 2010</p>
<p>I realised I cannot evaluate only part of the derivative (f.i. only the production/decay part)... so let's see what happens if I evaluate the full derivative for preconditioning. That actually works better.</p>
<p>This is actually the Krylov Band solver. </p>

</div>
</div>
<a class="anchor" id="a2f383ce6542557020a572bac16e77055"></a><!-- doxytag: member="solvers.c::lubksb" ref="a2f383ce6542557020a572bac16e77055" args="(double **a, int n, int *indx, double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lubksb </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>lubksb: does forward and backsubstitution of matrix a; in fact, a is not passed in its original form but as the LU decomposition of a rowwise permutation of a as returned by the function <a class="el" href="solvers_8c.html#aec72c11d5bed935ceab70026dabea1ac">ludcmp()</a>; the right hand side vector is called b, which also returns the solution vector to the calling function; indx is a vector that indicates the order of rows in the permutated matrix; n is the dimension of the matrix a (as in n x n). </p>

</div>
</div>
<a class="anchor" id="aec72c11d5bed935ceab70026dabea1ac"></a><!-- doxytag: member="solvers.c::ludcmp" ref="aec72c11d5bed935ceab70026dabea1ac" args="(double **a, int n, int *indx, double *d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ludcmp </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ludcmp: does an LU decomposition of matrix a, which is needed for in- verting the matrix; LU decomposition dissects the matrix into a lower and an upper triangular matrix that when multiplied, equal matrix a again; this function uses Crout's algorithm for the decomposition; the result is returned in a and con- tains the LU decomposition of a rowwise permutation of a; indx returns the order of the permutated rows; n is the size of matrix a (as in n x n); d returns +1 if number of row in- terchanges was even, -1 if odd. </p>

</div>
</div>
<a class="anchor" id="a270ab0adff5052cf4e1da796c23d99c4"></a><!-- doxytag: member="solvers.c::Meuler" ref="a270ab0adff5052cf4e1da796c23d99c4" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Meuler </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Meuler: propagates vin (of size n) from tin to tout by the Modified Euler method (this is NOT the midpoint method, see <a class="el" href="solvers_8c.html#aa769d6b7f7c138e8c659a7e7b1a256da">Rk2()</a>); the result is returned by vout </p>

</div>
</div>
<a class="anchor" id="a38d2c4e212d863c00c4275a5867287aa"></a><!-- doxytag: member="solvers.c::Milne" ref="a38d2c4e212d863c00c4275a5867287aa" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Milne </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Milne: propagates vin (of size n) from tin to tout by Milne-Simpson which is a predictor-corrector method; the result is retur- ned by vout</p>
<p>This solver was implemented by Konstantin Koslov, Dec 2001/Jan 2002</p>
<p>THIS SOLVER SEEMS TO BE BUGGY FOR SOME REASON, DO NOT USE IT!!!!! </p>

</div>
</div>
<a class="anchor" id="afc6326c0188c57c40b82a8e8977ba3d9"></a><!-- doxytag: member="solvers.c::mmid" ref="afc6326c0188c57c40b82a8e8977ba3d9" args="(double *vin, double *vout, double *deriv, double tin, double htot, int nstep, int n, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmid </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>htot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>mmid: implements the modified midpoint method used by BuSt; it subdi- vides a large step (htot) into nstep intervals and uses a mid- point method over the whole of htot, with a stepsize of 2*h except for the first and the last step, hence *modified* mid- point method); the nice thing about this method is that the error follows a power law depending on the stepsize, i.e. its error converges to zero really fast as h is diminished; this allows for good extrapolation to h=0 (see <a class="el" href="solvers_8c.html#ab7e5ce78d2e46e527abbbfcfbddef1a0">pzextr()</a> above) </p>

</div>
</div>
<a class="anchor" id="aea41aa29042230e96f756b96180271cd"></a><!-- doxytag: member="solvers.c::my_f_band" ref="aea41aa29042230e96f756b96180271cd" args="(realtype t, N_Vector y, N_Vector ydot, void *extra_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int my_f_band </td>
          <td>(</td>
          <td class="paramtype">realtype&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_Vector&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_Vector&nbsp;</td>
          <td class="paramname"> <em>ydot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>extra_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>wrapper function - to call the derivative </p>

</div>
</div>
<a class="anchor" id="ab7e5ce78d2e46e527abbbfcfbddef1a0"></a><!-- doxytag: member="solvers.c::pzextr" ref="ab7e5ce78d2e46e527abbbfcfbddef1a0" args="(int iest, double hest, double *vest, double *vout, double *dv, int n, const int KMAXX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pzextr </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>hest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>KMAXX</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>pzextr: uses polynomial extrapolation (Neville's algorithm) to evalu- ate v's at a the hypothetical stepsize 0; this is called Ri- chardson extrapolation; the arguments are:</p>
<ul>
<li>iest: how many steps have we done already before?</li>
<li>hest: current stepsize h</li>
<li>vest: v's obtained using current stepsize h</li>
<li>vout: extrapolated v's that will be returned</li>
<li>dv: array of error estimates to be returned</li>
<li>n: size of verst, vout and dv arrays Neville's algorithm uses a recursive approach to determine a suitable Lagrange polynomial for extrapolation by traversing a tableau of differences between Lagrange polynomials of in- creasing order; these differences are called C and D below (see Numerical Recipes in C, Chapter 3.1 for details) </li>
</ul>

</div>
</div>
<a class="anchor" id="aa769d6b7f7c138e8c659a7e7b1a256da"></a><!-- doxytag: member="solvers.c::Rk2" ref="aa769d6b7f7c138e8c659a7e7b1a256da" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rk2 </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rk2: propagates vin (of size n) from tin to tout by the Midpoint or Second-Order Runge-Kutta method; the result is returned by vout </p>

</div>
</div>
<a class="anchor" id="af811314e3f811a04f9dfc54a3368d359"></a><!-- doxytag: member="solvers.c::Rk4" ref="af811314e3f811a04f9dfc54a3368d359" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rk4 </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rk4: propagates vin (of size n) from tin to tout by the Fourth-Order Runge-Kutta method; the result is returned by vout</p>
<p>written by Joel Linton (somewhere around 1998) fixed and modified by Yoginho (somewhere around 2001) </p>

</div>
</div>
<a class="anchor" id="a22d1585560a34951ee703468643de616"></a><!-- doxytag: member="solvers.c::Rkck" ref="a22d1585560a34951ee703468643de616" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rkck </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rkck: propagates vin (of size n) from tin to tout by the Runge-Kutta Cash-Karp method, which is an adaptive-stepsize Rk method; it uses a fifth-order Rk formula with an embedded forth-oder for- mula for calucalting the error; its result is returned by vout</p>
<p>This solver was written by Marcel Wolf, Spring 2002. </p>

<p><p>used for storing intermediate steps </p>
</p>

</div>
</div>
<a class="anchor" id="a6087b8c0ab5c1170a4e3000289f7e7ea"></a><!-- doxytag: member="solvers.c::Rkf" ref="a6087b8c0ab5c1170a4e3000289f7e7ea" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rkf </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rkf: propagates vin (of size n) from tin to tout by the Runge-Kutta Fehlberg method, which is a the original adaptive-stepsize Rk method (Cash-Karp is an improved version of this); it uses a fifth-order Rk formula with an embedded forth-oder formula for calucalting the error; its result is returned by vout</p>
<p>This solver was written by Marcel Wolf, Spring 2002. </p>

</div>
</div>
<a class="anchor" id="a2704a4f583549482cb8f64b9b5b9897d"></a><!-- doxytag: member="solvers.c::simpr" ref="a2704a4f583549482cb8f64b9b5b9897d" args="(double *vin, double *vout, double *deriv, double *dfdt, double **jac, double tin, double htot, int nstep, int n, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simpr </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dfdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>htot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>simpr: implements the semi-implicit midpoint rule used by BaDe; it subdivides a large step (htot) into nstep intervals and uses a semi-implicit midpoint rule over the whole of htot, with a stepsize of 2*h except for the first and the last step; the nice thing about this method is that the error follows a power law depending on the stepsize, i.e. its error converges to 0 really fast as h is diminished; this allows for good extrapo- lation to h=0 (see <a class="el" href="solvers_8c.html#ab7e5ce78d2e46e527abbbfcfbddef1a0">pzextr()</a> above) </p>

</div>
</div>
<a class="anchor" id="a4a45ad1ee998bd642e3adf4ae72f5f1c"></a><!-- doxytag: member="solvers.c::SoDe" ref="a4a45ad1ee998bd642e3adf4ae72f5f1c" args="(double *vin, double *vout, double tin, double tout, double stephint, double accuracy, int n, FILE *slog, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoDe </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>stephint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delay solver - by Manu? </p>

</div>
</div>
<a class="anchor" id="a84cf8f0168e075e49d7d383ffd9efc1e"></a><!-- doxytag: member="solvers.c::stifbs" ref="a84cf8f0168e075e49d7d383ffd9efc1e" args="(double *v, double *deriv, int n, double *t, double htry, double accuracy, double *hdid, double *hnext, SolverInput *si, Input *inp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stifbs </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>htry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>hdid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>hnext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSolverInput.html">SolverInput</a> *&nbsp;</td>
          <td class="paramname"> <em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInput.html">Input</a> *&nbsp;</td>
          <td class="paramname"> <em>inp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>stifbs: this is the Bader-Deuflhard stepper function; it propagates the equations at a given overall stepsize and order, then evaluates the error and repeats the step with increased order if necessary, until the required accuracy is achieved; its arguments are:</p>
<ul>
<li>v: input and output v's over a give total stepsize</li>
<li>deriv: array of initial derivatives (at tin)</li>
<li>n: size of v and deriv</li>
<li>t: pointer to the current time</li>
<li>htry: initial stepsize to be tried</li>
<li>accuracy: relative accuracy to be achieved</li>
<li>hdid: returns the stepsize of the step we just did</li>
<li>hnext: returns the stepsize of the next step to be done </li>
</ul>

</div>
</div>
<a class="anchor" id="ae5bd7dd5efc4acce68f8b2adb32ec6d4"></a><!-- doxytag: member="solvers.c::writeInfo" ref="ae5bd7dd5efc4acce68f8b2adb32ec6d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writeInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get some info and write it out </p>

</div>
</div>
<a class="anchor" id="aa9f4951e44339690c0b36fcb131e25d6"></a><!-- doxytag: member="solvers.c::WriteSolvLog" ref="aa9f4951e44339690c0b36fcb131e25d6" args="(char *solver, double tin, double tout, double h, int n, int nderivs, FILE *slog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WriteSolvLog </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nderivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>slog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>WriteSolvLog: write to solver log file </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2013 for SimAnn by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
